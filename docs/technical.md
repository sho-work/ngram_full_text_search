# 技術説明資料
## 全体的な設計について
以下の参考文献の例として載っているような、
keyに対してvalueには出現位置のリストを与える典型的な転置インデックスとは異なり、
2-gramによって分割されたトークンをキーとして、valueには出力させたい住所テキストのリストを格納するようにしています。
これにより、一度転置インデックスを構築してしまえば、再度検索時にCSVファイルを読み取る必要がなくなり、転置インデックスさえ構築できていれば高速な検索が実現できます。

### 今回構築する転置インデックス
```
東京: {"101-0061 東京都千代⽥区三崎町", "101-0064 東京都千代⽥区猿楽町", "106-0032 東京都港区六本木一丁目"}
京都: {"101-0061 東京都千代⽥区三崎町", "101-0064 東京都千代⽥区猿楽町", "106-0032 東京都港区六本木一丁目"}
都港: {"106-0032 東京都港区六本木一丁目"}
```

### 参考文献に載っている一般的な転置インデックス
```
"a":      {2}
"banana": {2}
"is":     {0, 1, 2}
"it":     {0, 1, 2}
"what":   {0, 1}
```
参考: https://ja.wikipedia.org/wiki/%E8%BB%A2%E7%BD%AE%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9

## 各処理のコードの説明
実行するファイルを複数に分けるとそれぞれのファイルで`require`するものが出てくるかつ、わかりやすさの観点から、エントリポイントはAddressSearcherモジュールにしています。

### 転置インデックスの構築
TransposedIndexBuilder内の`::build`メソッドによって構築されます。
CSV行を1000件ずつ読み取って転置インデックスを構築し、分割してファイルに出力するようにしています。
1000件ずつ処理しているのは、以下の理由からです。
- 書き込み時にメモリを大量消費するのを防ぐため
- 分割する件数ごとの転置インデックスの構築・検索の計測結果から、合計の実行時間が一番高速なものを選んだ。
  - [転置インデックスの構築の計測結果](https://github.com/sho-work/ngram_full_text_search/discussions/5#discussion-6804080)
  - [検索の計測結果](https://github.com/sho-work/ngram_full_text_search/discussions/3#discussion-6803794)

### 転置インデックスのファイルへの出力・読み取りに関して
転置インデックスのファイルへの出力・読み取りはMarshalを用いるようにしました。
JSONを用いても良かったのですが、今回rubyにコードで検索を実現するので、他の言語で読み取れるファイルである必要性がないかつ、
以下のbenchmarkの結果から、Marshalの方が少しだけ早いので採用しました。

参考: https://gist.github.com/aishfenton/480059?permalink_comment_id=3115996#gistcomment-3115996

### 転置インデックスによる住所検索
AddressSearcher内の`::run`メソッドによって検索されます。
構築した転置インデックスのファイルを順番に読んでいきます。
検索条件の単語が複数のトークンに分割される場合はAND検索をしないといけないので、`Array#&`を使用するようにしました。
また、転置インデックスの構築時にファイルを分割しているので、各ファイルのループ内の検索処理ごとに、resultsに足し続けるようにしています。

参考: https://docs.ruby-lang.org/ja/latest/method/Array/i/=26.html

### その他
文字列を2-gramによってトークンに分割する処理は、以下の処理で共通で必要だったので、BigramResolverモジュールとして切り出しました。
- 転置インデックスの構築
- 転置インデックスによる住所検索

転置インデックスのファイルへの保存・転置インデックスを保存したファイルの読み込みは、
一つのモジュールにまとめた方が読みやすいかと思い、IndexStorageモジュールとして切り出しています。
